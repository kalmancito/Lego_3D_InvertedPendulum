#define DEC_OFFSET 5e-5
#define GYRO   IN_1   // Puerto 1: giroscopo
#define ACC   IN_4    // Puerto 4: acelerometro
#define SAMPLESIZE 100   // Numero muestras calibracion
#define MD OUT_A   // Puerto A: motor derecho
#define MI OUT_B   // Puerto B: motor izquierdo
#define M OUT_AB
#define WAIT 8
#define TCAIDA 1000

#define KGA -8.52 //negativo
#define KGS 3.15 // positivo
#define KA  -0.12 // negativo
#define KS -0.13 // negativo

float gOffset, velGyro, dt, ang, angGyro, angAcc;
float posMotor, velMotor;
int u = 0;
long tIni;

void calibracion();
void leerGyro();
void leerACC();

void calibracion(){
  
  int i, g, gMax, gMin;
  //float gMin, gMax;
  Off(M);
  do{
        TextOut(0,LCD_LINE1,"CALIBRACION");
          g = SensorHTGyro(GYRO);
          gMax = g;
          gMin = g;
          gOffset = 0.0;
        for (i=0; i<SAMPLESIZE; i++) {
           g = SensorHTGyro(GYRO);

           if (g>gMax){
              gMax = g;
              }
           else if (g<gMin){

              gMin = g;
              }

           gOffset += g;
           Wait(5);
        }
        }while((gMax - gMin) > 1)
     gOffset = gOffset/SAMPLESIZE + 1;

    TextOut(0, LCD_LINE4, "Avg:     ");
    NumOut(6*4, LCD_LINE4, gOffset);
    TextOut(0,LCD_LINE5,"Max:     ");
    NumOut(6*4, LCD_LINE5, gMax);
    TextOut(0,LCD_LINE6,"Min:     ");
    NumOut(6*4, LCD_LINE6, gMin);
  }



// Funcion para leer giroscopo
void leerGyro(){
     float medGyro;

      medGyro = SensorHTGyro(GYRO);
      gOffset = DEC_OFFSET * medGyro + (1-DEC_OFFSET) * gOffset;
      velGyro = medGyro - gOffset;
      angGyro = ang + velGyro*dt;
}

// Funcion para leer acelerometro
void leerAcc(){
     int ax,ay,az;
     ReadSensorHTAccel(ACC, ax, ay, az);
     angAcc = atan2(ay,ax)*180/3.141592;
}

void leerMotores(){

long mrc = 0, mrcAnt;
long dmrc, dmrc2 = 0, dmrc3 = 0, dmrc4 = 0;

mrcAnt = mrc;
mrc = (MotorTachoCount(MD)+ MotorTachoCount(MI))/2;

dmrc = mrc - mrcAnt;

posMotor += dmrc;

velMotor = (dmrc+dmrc2+dmrc3+dmrc4)/(4*dt);

dmrc4 = dmrc3;
dmrc3 = dmrc2;
dmrc2 = dmrc;
}

inline void CalcularTiempo(long cont){
       if(cont == 0){
          dt = 0.0055;
          tIni = CurrentTick();
       } else{
          dt = (CurrentTick() - tIni)/(cont*1000.0);
       }
}


task main() {
  ClearScreen();
  int vv, offset;

  SetSensorHTGyro(GYRO);
  SetSensorLowspeed(ACC);
  Wait(1000);

  //---------- CALIBRACION ---------------

  calibracion();
  Wait(3000);
  
  ClearScreen();
}

task Control(){

  Follows(main);
  
  long cont = 0;
  long tMotorPosOK;
  int uAnt, du;
  
  ClearScreen();
  
  tMotorPosOK = CurrentTick();
  ResetRotationCount(MD);
  ResetRotationCount(MI);

  while(true){
  
  CalcularTiempo(cont++);
  
  if(cont%10 == 0){
  ClearScreen();
  }
  
  leerGyro();
  leerAcc();
  leerMotores();
  
  ang = 0.9*angGyro + 0.1*angAcc;

  uAnt = u;
  u = KGA*ang + KGS*velGyro + KA*posMotor + KS*velMotor;

  //du = u - uAnt;

  //u = u + 1*du;
  
  if(abs(u) < 100)
       tMotorPosOK = CurrentTick();

  if(u > 100){
       u = 100;
  } else if(u < -100){
       u = -100;
  }

  OnFwd(M, u);

  
  if((CurrentTick() - tMotorPosOK) > TCAIDA){
    break;
  }
  
  //Wait(8);

  NumOut(0*4, LCD_LINE1, angGyro);
  NumOut(0*4, LCD_LINE2, velGyro);
  NumOut(0*4, LCD_LINE3, angAcc);
  NumOut(0*4, LCD_LINE4, ang);
  NumOut(0*4, LCD_LINE5, dt);
  NumOut(0*4, LCD_LINE6, posMotor);
  NumOut(0*4, LCD_LINE7, velMotor);
  NumOut(0*4, LCD_LINE8, u);

  }
  Off(M);
}

